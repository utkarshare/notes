<!doctype html>
<html lang="en">
	<head>
		<link rel="stylesheet" href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/styles/default.min.css>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/highlight.min.js"></script>
		<script>hljs.highlightAll();</script>
		<script  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script>
		<link rel="stylesheet" href="style.css"> 
		<meta charset="utf-8">
		<title> C Previous Year Questions for GATE </title>
	</head>

	<body>
		<div id="container">
			<div id="question">
				<b> Aliasing </b> in the context of programming languages refers to 
				<div id="options">
					<ol>
						<li> multiple variables having the same memory location</li>
						<li> multiple variables having the same value</li>
						<li> multiple variables having the same identifier </li>
						<li> multiple uses of the same variable</li>
					</ol>
				</div>


				<div id="solution">
					<b>Aliasing</b> refers to multiple variables having the same memory location. In fact, in C, <b> two pointers are said to be aliased </b> if they point to the same memory location.
				</div>
			</div>

			<div id="question">
					An unrestricted use of the "go to" statement is harmful because of which of the following reason (s):
					<div id="options">
							<ol>
									<li>It makes it more difficult to verify programs</li>
									<li>It makes programs more inefficient</li>
									<li>It makes it more difficult to modify existing programs</li>
									<li>It results in compiler generating longer machine code</li>
							</ol>
					</div>
					<div id="solution">
									Usage of gotos makes it <b> more difficult to verify programs </b> as argued by Edsger Djikstra in his "Goto Statements Considered Harmful"
					</div>
			</div>

			<div id="question">
					Consider the following high level programming language segments. Give the contents of the memory locations for variables \(W\), \(X\), \(Y\) and \(Z\) after the execution of the program segment. The values of the variables \(A\) and \(B\) are \(5C_{16}\) and \(92_{16}\) respectively. Also indicate error conditions if any
							<pre><code class="cpp">
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
unsigned char A, B, W, X, Y;
unsigned int Z;

int main(void)
{
	A = 0x5C;
	B = 0x92;
	X = A + B;
	Y = abs(A-B);
	W = A - B;
	Z = A * B;

	return 0;
}
							</code></pre>
				<div id="solution">
						<ul>
								<li>We have \(A = 5C = 0101_{5} 1101_{C} = 5 \times 16^{1} + 12 \times 16^{0}  = 80 + 12 = 92\)</li>
								<li>We have \(B = 92 = 1001_{9} 0010_{2} = 5 \times 16^{1} + 2 \times 16^{0} = 144 + 2 = 146\)</li>
								<li>We have \(X = 146+92 = 238 = EE_{16}\)</li>
								<li>We have \(Y = abs(A-B) = abs(146-92) = 54 = 36_{16}\)</li>
								<li>We have \(W = A-B = 92-146 = -54\). To represent a negative number, we use \(2\)'s complement system. So \(-54\) can be found by taking the \(2\)'s complement of the binary representation of \(54\). Now \(54 = 00110110_{2}\). It's \(2\)'s complement is \(11001001+1 = 11001010\ = CA_{16}\)</li>
								<li>We have \(Z = 92 \times 146 = 13432\). To get it's hexadecimal, we divide succesively
										<ul>
												<li> \(13432 mod 16 = 8\) and \(\lfloor13432\div16\rfloor = 839\)</li>
												<li> \(839 mod 16 = 7\) and \(\lfloor839\div16\rfloor = 52\)</li>
												<li> \(52 mod 16 = 4\) and \(\lfloor52\div16\rfloor = 3\)</li>
												<li> \(3 mod 3 = 3\) and \(\lfloor3\div16\rfloor = 0\)</li>
										</ul>
									Thus, \(Z = 3478_{16}\)</li>
						</ul>
				</div>
			</div>

			<div id="question">
					Let \(x\) be an integer which can take the value of 0 or 1. The statement
					<pre><code>if (x==0) x = 1; else x = 0;</pre></code>
					is equivalent to which one of the following:
					<ol>
							<li> \(x = 1 + x\)</li>
							<li> \(x = 1 - x\)</li>
							<li> \(x = x - 1\)</li>
							<li> \(x = 1\%x\)</li>
					</ol>
					<div id="solution">
							<ul>
									<li>When \(x = 1\) it becomes \(0\)</li>
									<li>When \(x = 0\) it becomes \(1\)</li>
									<li>Clearly, when \(x = 1\), \(1 - x = 0\), and when \(x = 0\), \(1 - x = 1\), therefore the solution is \(1-x\)</li>
									<li>None of the other options work for both the cases of \(x\)</li>
							</ul>
					</div>
			</div>

			<div id="question">
					Consider the following C program. Assume that \(swap(\&x, \&y)\) exchanges the contents of \(x\) and \(y\):
					<pre><code>
int main()
{
	int array[] = {3, 5, 1, 4, 6, 2};
	int done =0;
	int i;
	while (done==0) {
		done =1;
		for (i=0; i<=4; i++) {
		if (array[i] &lt;  array[i+1]) {
		swap(&array[i], &array[i+1]);
		done=0;
		}
	}
	for (i=5; i>=1; i--) {
		if (array[i] &ct; array[i-1]) {
			swap(&array[i], &array[i-1]);
			done =0;
		}
									}
	}
printf(“%d”, array[3]);
return 0;
}
					</code></pre>
					The output of the program is _______
					<div id="solution">
							<ul>
									<li>You could trace through the whole program and see what the output is, but there's a slightly simpler method</li>
									<li>Notice that there is one big <font face=monospace>while</font> loop that will execute until <font face=monospace>done=1</font>. There are two <font face=monospace>for</font> loops inside the while loop.</li>
									<li>The swapping only happens inside the <font face=monospace>for</font> loop.</li>
									<li>Notice that in the first <font face=monospace>for</font> loop, the contents of the array are being swapped such that the <b>smaller element is moving towards the right end</b></li>
									<li>In the second <font face=monospace>for</font> loop, the contents of the array are being swapped such that the larger element is moving towards the left, or it's equivalent <b>the smaller elements are moving towards the right</b></li>
									<li>Every time there is a swap, the <font face=monospace>done</font> variable is set to \(0\). This implies that the <font face=monospace>done</font> variable will only be 1 at the end of the while if there are <b>no swaps</b>.</li>
									<li>The only way that there will be no swaps is when the array is in <b>descending order</b></li>
									<li>Thus, this routine sorts the array in descending order</li>
									<li>If the array is sorted in descending order, it is \([6, 5, 4, 3, 2, 1]\). So, \(array[3]=3\)</li>
							</ul>
					</div>
			</div>
		</div>
</body>
</html>
